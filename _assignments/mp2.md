---
layout: assignment
title: "MP2: Terrain Modeling"
index: 10
due: "March. 18, 2021 @ 11:59 PM"
material: ~
points: 100
rubric:
  -
    name: Runs and renders
    points: 10
    description: Program runs without crashing and renders visible polygons.
  -
    name: Commented
    points: 10
    description: Each function in your code is commented in the required style.
  - 
    name: Normals
    points: 20
    description: Normal vectors for the terrain are computed and handled correctly.
  -
    name: Terrain Generation
    points: 20
    description: The terrain is modeled using the random partition method.
  - 
    name: Elevation Color Map
    points: 20
    description: The shading of the terrain changes by mapping different ranges of elevation to different colors.
  - 
    name: Phong Shading
    points: 10
    description: Shading model computation is in the fragment shader.
  -
    name: Creativity
    points: 10
    description: The color map is visually interesting and the terrain exhibits good aesthetic quality (e.g. not totally random).

---

For your second Machine Problem, you will procedurally model a piece of terrain. 

+ The terrain will be finite...do not be concerned about being able to see the boundary.
+ The scene will be static...meaning you will not interactively change your view of it/
+ **We will add interaction in a following MP, so write good code that you can reuse.** 

### 1. Terrain Generation ###

Many basic terrain modeling algorithms employ something called *Perlin noise* to create a highly detailed natural appearance. Invented by Ken Perlin in 1982 while working on the movie *Tron*, Perlin noise uses randomness and repetition to synthesize 2D and 3D textures. In 1997, Perlin won an Academy Award for Technical Achievement from the Academy of Motion Picture Arts and Sciences for this contribution to graphics. Perlin noise and techniques based off of it are still widely used in games and movies today.

Realistic terrain generation in modern games require tools that do more than just model the basic underlying terrain...these tools support operations like creation of vegetation and roads and erosion. See [this talk by Ubisoft developer Etienne Carrier](https://www.youtube.com/watch?v=NfizT369g60) if you are interested in seeing the tools technical artists use these days. 
![](https://illinois-cs418.github.io//img/perlin1.jpg)



### The Faulting Method

For this MP we will write code to generate a basic 3D terrain. We won't be using Perlin's function...instead we will do something conceptually similar but less efficient...but easier to implement. This method is called _the faulting method_ and was initially proposed by  Benoit Mandelbrot in 1982.

You can find a summary of the faulting method in section 3.1.2 of the following survey paper on terrain generation algorithms:

_A Review of Digital Terrain Modeling_. Eric Galin, Eric Gu√©rin, Adrien Peytavie, et al.. [PDF](https://hal.archives-ouvertes.fr/hal-02097510/file/A%20Review%20of%20Digital%20Terrain%20Modeling.pdf)

#### Faulting Method Overview

The first step in our implementation will be to create a flat, triangulated surface in which all the vertices have $$z$$ coordinates of $$0$$.
![](https://illinois-cs418.github.io//img/rpart0-2.png)

In the above image, the view is generated by using a _view_ transformation based on a matrix generated by a call to <code>glmatrix.mat4.lookAt(out, eye, center, up)</code> that has us looking down onto the $$z=0$$ plane.

After that we will repeatedly, randomly generate an imaginary fault plane cutting through the terrain that partitions the vertices. On one side of the plane we will increase the height of each vertex by some amount $$\Delta$$. On the other side, we decrease the vertex heights by $$\Delta$$. After enough iterations, you should see something resembling a 3D terrain.
![](https://illinois-cs418.github.io//img/rpart1.png)

Here it is without the triangle boundaries, shaded using the Phong reflectance model.
![](https://illinois-cs418.github.io//img/rpart2-2.png)

### Implementation 

You can use the following starter code:

+ MP2.html [Link](https://github.com/illinois-cs418/illinois-cs418.github.io/raw/master/Examples/WebGL2/Terrain/MP2.html)
+ MP2.js [Link](https://github.com/illinois-cs418/illinois-cs418.github.io/raw/master/Examples/WebGL2/Terrain/MP2.js)
+ Terrain.js [Link](https://github.com/illinois-cs418/illinois-cs418.github.io/raw/master/Examples/WebGL2/Terrain/Terrain.js)
+ glmatrix-min.js [Link](https://github.com/illinois-cs418/illinois-cs418.github.io/raw/master/Examples/WebGL2/Terrain/gl-matrix-min.js)

Your tasks are the following:

#### Implement the method `generateTriangles()` in Terrain.js

We will generate a mesh using an indexed face representation. This means we will have one block of data that specifies the positions of the vertices and another block of data that specifies the connectivity of the triangles. This function fills in an array called `positionData` which contains the $$x,y,z$$ coordinates of each vertex. Theses positions can be generated in the following manner:

~~~javascript
    var deltaX=(this.maxX-this.minX)/this.div;
    var deltaY=(this.maxY-this.minY)/this.div;
    
    for(var i=0;i<=this.div;i++)
       for(var j=0;j<=this.div;j++)
       { 
           this.positionData.push(this.minX+deltaX*j);
           this.positionData.push(this.minY+deltaY*i);
           this.positionData.push(0);
       }
~~~



The function also will generate the triangles for the mesh by filling `faceData`. Each face will represented by a triple $$v_i,v_j,v_k$$ of integers which are the indices of the vertices at the triangle corners. For example$$0,1,10$$ would mean the triangle is formed by vertex 0, 1, and 10 in `positionData`. SInce `positionData` is actually a 1D array of floats, with each vertex requiring 3 floats, the start of the coordinates for the vertices will be at index 0, index 3, and index 30 in `positionData`.

To generate the `faceData` imagine the vertices as a 2d grid of points. Each rectangle of the grid can be formed by two triangles. The indices of the vertices at the corner of a triangle are determined by their order of insertion in the above code.  For example, the triangles in the lower left corner of the grid will be $$0,1,T+1$$ and $$1,T+2,T1$$ where $$T$$ is the number of triangles along the $$x$$-axis. **Note** these triangles must have their vertices specified in counter-clockwise (CCW) order for normal vectors to be generated in the correct direction.

#### Implement the methods `getVertex(v,i)` and `setVertex(v,i)` in Terrain.js

These methods are accessor and mutator methods to help make working with the `positonData` syntactically simpler. It allows you to use a single function call to work with the $$x,y,z$$ coordinates of a vertex by abstracting the implementation of `positionData` as a flat array of floats. Here is an exampled implementation of `getVertex`

~~~javascript
/**
     * Returns the x,y,z coords of the ith vertex.
     * @param {Object} v An array of length 3 to hold the x,y,z coordinates.
     * @param {number} i The index of the vertex to get.
     */
    getVertex(v, i) {
        v[0]=this.positionData[i*3];
        v[1]=this.positionData[i*3 + 1];
        v[2]=this.positionData[i*3 + 2];
    }
~~~



#### Implement the method <code>shapeTerrain</code> in Terrain.js

The rectangle for your surface mesh should have corners $$(x_{min},y_{min},0)$$ and $$(x_{max},y_{max},0)$$. To implement the faulting method you need to:

##### Construct a Random Fault Plane

We will construct a fault plane cutting through the terrain by generating a random point $$p$$ and random direction vector $$\vec{n}$$ to define the plane.

1. First generate a random point $$p$$ in the rectangle  $$(x_{min},y_{min},0) \times (x_{max},y_{max},0)$$.  
2. Generate a random normal vector $$\vec{n}$$ for the plane $$<x_n,y_n,0>$$, where $$x_n,y_n$$ is a point uniformly sampled on the unit circle.
   You can easily generate a random vector using <code>glMatrix.vec2.random(out)</code> 
   Alternatively, if $$\theta$$ is a random angle in $$[0,2\pi]$$ then an appropriate random normal would be $$\vec{n}=(\cos{\theta},\sin{\theta},0)$$.

##### Raise and Lower Vertices

Iterate over the vertices and do the following:

1.  Given a vertex $$b$$, test which side of the plane that vertex falls on by using the dot product test $$ (b-p) \cdot n \ge  0 $$.
    ![](https://illinois-cs418.github.io//img/dottest.jpg)
2.  If $$b$$ is in the negative half-space, **lower** the $$z$$ coordinate of by some amount $$\Delta$$.
3.  If $$b$$ is in the positive half-space, **raise** the $$z$$ coordinate of by some amount $$\Delta$$.
    1. **Optional** You may compute the distance $$r=\bold{d}(b,\Phi_i)$$ from $$b$$ to the fault plane $$\Phi_i$$ and alter the $$\Delta$$ you use for each vertex by a coefficient function $$g(r)=(1-r/R)^2)^2$$ for $$r<R$$ and $$g(r)=0$$ where $$R$$ is a parameter you determine. 
4.  Repeat this process making multiple passes over the vertices generating faults and altering vertex heights until you have a decent looking terrain.
    1. **Important** Let $$\Delta_i$$ be the faulting parameter you used in pass $$i$$ over the vertices. For the next pass you should use $$\Delta_{i+1} = \frac{\Delta_i}{2^H}$$ where $$H\in[0,1]$$ 

##### Parameters

You will need to experiment with the parameters of algorithm to find ones that give good results. The images above used 100 iterations of partitioning on a $$64 \times 64$$ grid of vertices spanning a unit square with $$\Delta = 0.005$$ and $$H=$$0. You should use a larger value for $$H$$.

####  Use <code>gl.drawElements</code> in Terrain.js

Your implementation should generate an indexed mesh and render it using the WebGL function <code>void gl.drawElements(mode, count, type,offset)</code>The starter code does this, but  **you should pay attention to the `type` parameter as the type **`gl.UNSIGNED_SHORT` will limit your mesh to having only 65536 vertices. If you want more, you will need to use the <code>gl.UNSIGNED_INT</code>.

#### Complete <code>calculateNormals()</code> in Terrain.js

In order for the mesh to be shaded correctly **you will also need to generate per-vertex normals** for the mesh. Each normal is a vector perpendicular to the mesh at the vertex, and should be  computed as a _**triangle area-weighted average**_ of the normals of the triangles that surround the vertex. These normals will be another attribute that you will need to send down to the vertex shader. 

Generating per-vertex normals is discussed in Week 5 (Feb 23) Lecture available at this [Link](https://illinois-cs418.github.io/schedule).

#### Implement a perspective view in MP2.js

Your code should generate a view matrix and a perspective projection matrix in the JS portion of the app and send them to the vertex shader...and use them to transform the vertices. You should use the [glMatrix library](http://glmatrix.net/) functions `lookAt(out, eye, center, up)` and `perspective(out, fovy, aspect, near, far)` to generate the matrices. It is up to you to understand how to specify the parameters to generate a good view. 

#### Implement the Phong reflection model and Phong shading

Implement the Phong illumination model with Phong shading. This means your shading calculations should be done per-fragment..meaning in the fragment shader. You can position your light source(s) anywhere in the scene as long as the rendered images are well-lit.  

The starter code implements the Phong reflection model with _Gouraud_ shading. In order to move the computation to the fragment shader you will need to do the following:

1. Send an interpolated normal vector from the vertex shader to the fragment shader.
2. Send an interpolated position value from vertex shader to the fragment shader. 
3. Calculate the reflection vector in the fragment shader instead of the vertex shader.
4. Send the light position and colors to the fragment shader from your JS code as `uniform` variables.

For this MP you will generate material colors in the vertex shader...you will need to generate a color for the terrain based on elevation as described below. You can set the shininess coefficient $$\alpha$$ however you wish (e.g.  $$\alpha=1$$ for all shading computations is acceptable ).

#### Implement an elevation-based colormap for the terrain

In your shading calculation, you should assign material colors (the $$k$$ values in the Phong model) to vertices based on the elevation of the vertex. If you use the $$z$$-coordinate as elevation, that means you should base your color assignment on the value of the $$z$$-coordinate. For example, you could define four different intervals of z values and assign blue to the vertices in the lowest interval, green to the second lowest, brown to the second highest, and white to the highest. **You should define your own color scheme...you can be creative and do not need to mimic the picture shown here.**

![Example Terraing](https://illinois-cs418.github.io/img/terrain.PNG)

To make the calculation simpler, we should implementing the following:

1. In Terrain.js, implement methods `getMaxElevation()` and `getMinElevation()` that return the max and min $$z$$ coordinate in the terrain.

2. Send these values to the vertex shader as `uniform` variables.

3. In the vertex shader, compute a normalized elevation for the vertex using code like this:

   ~~~~~~~~glsl
   in vec3 vertexPosition;
   
   uniform float minZ;
   uniform float minZ;
   
   void main(void) {
        float  nrmZ;
      	 nrmZ = vertexPosition.z-minZ/(maxZ-minZ);
   
      	 ....
           }
   ~~~~~~~~

4. Then, you can set the values of ` kAmbient` and `kDiffuse` using a colormap based on `nrmZ` knowing that `nrmZ`$$\in [0,1]$$

Note that `kAmbient` and `kDiffuse` must be local variables in the shader, they cannot be declared as `uniform` variables in the shader since you are assigning values to them in the shader code. 

You can keep `kSpecular = vec4(1,1,1,1)` for this MP.

After assigning the material colors in the vertex shader, pass them as varyings using <code>out</code> in vertex shader to send the colors to an <code>in</code> variables in the fragment shader to complete the shading process.

 **Debugging Tips** 

- Start by generating a small flat terrain (for example 3 vertices by 3 vertices). 
  Use this to set up the view you want.
- Then, add in the ability to set the z coordinates of the vertices. Do something simple like random heights.
- Then, work on implementing the terrain generation algorithm.
- Use the newest version of the [glMatrix library](https://glmatrix.net/)
